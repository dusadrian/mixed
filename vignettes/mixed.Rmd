---
title: "Why this package"
output:
  rmarkdown::html_vignette:
    css: "custom.css"
    toc: true
    toc_float: false
    toc_depth: 4
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Why this package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(mixed)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ""
)
```

# The problem

The R ecosystem already has some very good packages that deal with labelled objects.  In particular,
the inter-connected packages **haven** and **labelled** already provide the functionality most users
would ever need.

As nice and useful these packages are, it has become apparent they have some fundamental design
features that run, in some situations, against users' expectations. This has a lot to do with the
treatment of declared missing values, that are fundamental for the social sciences. 

The following minimal example (adapted from the vignette in package **haven**) illustrates the
situation:


```{r}
x1 <- labelled_spss(c(1:5, 99), c(Missing = 99), na_value = 99)
x1
```

There are 5 normal values (suppose they represent number of children), and one declared missing value
coded 99. This value *acts* as a missing value, but it is different from a regular missing value in R,
coded NA. The later stands for any missing information (something like an empty cell) regardless of
the reason.

Here, on the other hand, the cell is *not* empty, but the value 99 is not a valid value either. It
cannot possibly represent 99 children in the household, but for instance it could mean the respondent
did not want to respond. It is properly identified as missing, with:

```{r}
is.na(x1)
```

But if performing a mean, for instance, the normal expectation is that value 99 would not play any role in
the calculations (since it is *missing*). However:

```{r}
mean(x1)
```

This means the value 99 did play an active role despite being identified as "missing". In an ideal
world, the expected mean would be 3, or at best employ the argument `na.rm = TRUE` if the result is NA
because of the declared missing value.

A solution to this problem is offered by package **labelled**, which has a function called
`user_na_to_na()`:


```{r}
mean(user_na_to_na(x1), na.rm = TRUE)
```

This function converts the declared missing values into regular NA values, in which situation the
result is missing and the argument `na.rm` is needed to calculate the mean.


# The mixed solution

While solving the problem, this above solution forces two additional operations:

* converting the declared missing values, and

* employing the `na.rm` argument.

This should not be necessary, especially if (and it is extremely likely that) users may forget the
declared missing values are not actually missing values. To completely solve this situation, package
**mixed** creates a very similar object, where declared missing values are actually stored (hence
interpreted as) regular NA missing values in R.


```{r}
x2 <- mixed_labelled(c(1:5, 99), c(Missing = 99), na_value = 99)
x2
```

It is now obvious that value 99 is not anymore a regular number, but a tagged missing value. More
importantly, it circumvents the need to convert declared missing values to regular NAs, since they are
already stored as tagged NA values. The average value is calculated simply as:

```{r}
mean(x2)
```

Notice that neither `user_na_to_na()`, nor employing `na.rm = TRUE` are necessary. Despite being stored
as an NA value (tagged, but still NA), the value 99 is not equivalent to an *empty cell*. The
information does exist, it is just ignored in the calculations.

The `na.rm = TRUE` is only necessary if there are unexplained missing values in the data:


```{r}
mean(c(x2, NA))

mean(c(x2, NA), na.rm = TRUE)
```

As it can be seen, concatenating on this vector creates a similar one of the same class:

```{r}
x2 <- c(x2, -1)
x2
```


# Differences and added value

It should be made obvious that packages **haven** and **labelled** are excellent packages which are not
inherently doing a bad thing: the very same result is obtained, just via a different route. Package
**mixed** should not even be necessary, if the design philosophy of these packages would be different. 

Another thing worth mentioning is that package **mixed** is not competing with these packages. Quite
the contrary, it is built on exactly the same foundation and just *adds* functionality on top of them.
This makes it possible to use many of the functions from package **labelled**, despite them not being
written specifically for package **mixed**.

For instance the function `val_labels()` to add / change value labels:

```{r}
val_labels(x2) <- c(DK = -1, NR = 99)
x2
```

The value -1 is now properly labelled, and it can further be declared as missing using the function
`na_values()` from the same package **labelled**:

```{r}
na_values(x2) <- c(-1, 99)
x2
```


While creating the `mixed_labelled` class to deal with the declared missing values, other interesting
possibilities surfaced. Consider the following treatment of the tagged NA values in package **haven**:


```{r}
haven::tagged_na('a')
```

The NA value is tagged, but this fact remains unknown if the command creating it would not be available.
On the other hand, package **mixed** has a counterpart function:

```{r}
tag('a')
```

This direct formatting happens because tagged NA values in this package are allocated a class "tagged"
that allows custom printing methods. Such treatment of tagged NA values is propagated to entire
vectors:

```{r}
c(1, tag('a'))
```

The function `tag()` is similar to the function `tagged_na()` from package **haven**, with some
improvements:

* instead of one (the first) character, it accepts two

* it also accepts integer numbers, not only characters


```{r}
tag('ab')

tag(12345)
```

Unlike package **haven** which uses one extra byte to tag the value, package **mixed** uses two extra
bytes, and the available 16 bits can fit any number between -32768 to 32767. The numeric tagged value
is then properly extracted as numeric:


```{r}
get_tag(tag(12345))
```

This is already an improvement over the **haven** related functions, because an NA value tagged with a
number is essentially a missing... *number*.

Larger values are internally tagged as characters, as long as there are not more than 26 such large
values in a given vector:

```{r}
tag(99999)
```
