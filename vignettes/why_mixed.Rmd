---
title: "Why this package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Why this package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(mixed)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## The problem

The R ecosystem already has some very good packages that deal with labelled objects.  In particular, the inter-connected packages **haven** and **labelled** already provide the functionality most users would ever need.

As nice and useful these packages are, it has become apparent they have some fundamental design features that run, in some situations, against users' expectations. This has a lot to do with the treatment of declared missing values, that are fundamental for the social sciences. 

The following minimal example (adapted from the vignette in package **haven**) illustrates the situation:


```{r}
x1 <- labelled_spss(c(1:5, 99), c(Missing = 99), na_value = 99)
x1
```

There are 5 normal values (suppose they represent number of children), and one declared missing value coded 99. This value *acts* as a missing value, but it is different from a regular missing value in R, coded NA. The later stands for any missing information (something like an empty cell) regardless of the reason.

Here, on the other hand, the *cell* is not empty, however the value 99 is not a valid value either. It cannot possibly represent 99 children in the household, but for instance it could mean the respondent did not want to respond. It is properly identified as missing, with:

```{r}
is.na(x1)
```

If performing a mean, for instance, the normal expectation is that value 99 would not play any role in the calculations (since it is *missing*). However:

```{r}
mean(x1)
```

This means the value 99 did play an active role despite being identified as "missing". In an ideal world, the expected mean would be 3, or at best employ the argument `na.rm = TRUE` if the result is NA because of the declared missing value.

A solution to this problem is offered by package **labelled**, which has a function called `user_na_to_na()`:


```{r}
mean(user_na_to_na(x1), na.rm = TRUE)
```

This function converts the declared missing values into regular NA values, in which situation the result is missing and the argument `na.rm` is needed to calculate the mean.


## The mixed solution

While solving the problem, this above solution forces two additional operations:

* converting the declared missing values, and

* employing the `na.rm` argument.

This should not be necessary, especially if (and it is extremely likely that) users forget the declared missing values are not actually missing values. To completely solve this situation, package **mixed** creates a very similar object, where declared missing values are actually stored (hence interpreted as) regular `NA` missing values in R.


```{r}
x2 <- mixed_labelled(c(1:5, 99), c(Missing = 99), na_value = 99)
x2
```

It is now obvious that value 99 is not anymore a regular, but a tagged missing value. More importantly, it circumvents the need to convert declared missing values to regular `NA`s, since they are already stored as tagged `NA` values. The average value is calculated simply as:

```{r}
mean(x2)
```

Notice that neither `user_na_to_na()`, nor employing `na.rm = TRUE` are necessary. Despite being stored as an `NA` value (tagged, but still `NA`), the value `99` is not equivalent to an *empty cell*. The information does exist, it is just ignored in the calculations.

Concatenating on this object creates a similar object:

```{r}
x2 <- c(x2, -1)
x2
```


## Differences and added value

It should be made obvious that packages **haven** and **labelled** are excellent packages which are not inherently doing a bad thing: the very same result is obtained, just via a different route. Package **mixed** should not be necessary, if the design philosophy of these packages would be different. 

Another thing to clarify is that package **mixed** is not competing with these packages. Quite the contrary, it is built on exactly the same foundation and *adds* functionality on top of these two. This makes it possible to use many of the functions from package **labelled**, despite them being written in tandem with package **haven**.

For instance the function `val_labels()` to add / change value labels:

```{r}
val_labels(x2) <- c(DK = -1, NR = 99)
x2
```

The value -1 is now properly labelled, and it can further be declared as missing using the function `na_values()` from the same package **labelled**:

```{r}
na_values(x2) <- c(-1, 99)
x2
```


While creating the `mixed_labelled` class to deal with the declared missing values, other interesting possibilities opened up. Consider the following treatment of the tagged NA values in package **haven**:


```{r}
haven::tagged_na('a')
```

The NA value is tagged, but this would remain unknown without the command. On the other hand:

```{r}
tag('a')
```

This is possible because tagged NA values in package **mixed** are allocated a class `tagged` that allows custom formatting and printing. This treatment of tagged NA values is propagated to entire vectors:

```{r}
c(1, tag('a'))
```

The function `tag()` is similar to the function `tagged_na()` from package **haven**, with some improvements:

* instead of one (the first) character, it accepts two

* it also accepts numbers, not only characters


```{r}
tag('ab')

tag(12345)
```

This was made possible because, as it turns out, it is possible to tag an NA value using not only one but actually two extra bytes, and the available 16 bits can fit any number between -32767 to 32767. The numeric tagged value is then properly extracted as numeric:


```{r}
get_tag(tag(12345))
```

This is already an improvement over the **haven** related functions, because an NA value tagged with a number is essentially a missing... *number*.


